# Copyright 2016-2018 The Meson development team

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations

import argparse, datetime, glob, json, os, platform, shutil, sys, tempfile, time
import cProfile as profile
from pathlib import Path
import typing as T

from . import build, coredata, environment, interpreter, mesonlib, mintro, mlog
from .mesonlib import MesonException

git_ignore_file = '''# This file is autogenerated by Meson. If you change or delete it, it won't be recreated.
*
'''

hg_ignore_file = '''# This file is autogenerated by Meson. If you change or delete it, it won't be recreated.
syntax: glob
**/*
'''


# Note: when adding arguments, please also add them to the completion
# scripts in $MESONSRC/data/shell-completions/
def add_arguments(parser: argparse.ArgumentParser) -> None:
    coredata.register_builtin_arguments(parser)
    parser.add_argument('--native-file',
                        default=[],
                        action='append',
                        help='File containing overrides for native compilation environment.')
    parser.add_argument('--cross-file',
                        default=[],
                        action='append',
                        help='File describing cross compilation environment.')
    parser.add_argument('-v', '--version', action='version',
                        version=coredata.version)
    parser.add_argument('--profile-self', action='store_true', dest='profile',
                        help=argparse.SUPPRESS)
    parser.add_argument('--fatal-meson-warnings', action='store_true', dest='fatal_warnings',
                        help='Make all Meson warnings fatal')
    parser.add_argument('--reconfigure', action='store_true',
                        help='Set options and reconfigure the project. Useful when new ' +
                             'options have been added to the project and the default value ' +
                             'is not working.')
    parser.add_argument('--wipe', action='store_true',
                        help='Wipe build directory and reconfigure using previous command line options. ' +
                             'Useful when build directory got corrupted, or when rebuilding with a ' +
                             'newer version of meson.')
    parser.add_argument('--clearcache', action='store_true', default=False,
                        help='Clear cached state (e.g. found dependencies). Since 1.3.0.')
    parser.add_argument('builddir', nargs='?', default=None)
    parser.add_argument('sourcedir', nargs='?', default=None)

class MesonApp:
    def __init__(self, options: argparse.Namespace) -> None:
        self.options = options
        (self.source_dir, self.build_dir) = self.validate_dirs()
        if options.wipe:
            # Make a copy of the cmd line file to make sure we can always
            # restore that file if anything bad happens. For example if
            # configuration fails we need to be able to wipe again.
            restore = []
            with tempfile.TemporaryDirectory() as d:
                for filename in [coredata.get_cmd_line_file(self.build_dir)] + glob.glob(os.path.join(self.build_dir, environment.Environment.private_dir, '*.ini')):
                    try:
                        restore.append((shutil.copy(filename, d), filename))
                    except FileNotFoundError:
                        # validate_dirs() already verified that build_dir has
                        # a partial build or is empty.
                        pass

                coredata.read_cmd_line_file(self.build_dir, options)

                try:
                    # Don't delete the whole tree, just all of the files and
                    # folders in the tree. Otherwise calling wipe form the builddir
                    # will cause a crash
                    for l in os.listdir(self.build_dir):
                        l = os.path.join(self.build_dir, l)
                        if os.path.isdir(l) and not os.path.islink(l):
                            mesonlib.windows_proof_rmtree(l)
                        else:
                            mesonlib.windows_proof_rm(l)
                finally:
                    self.add_vcs_ignore_files(self.build_dir)
                    for b, f in restore:
                        os.makedirs(os.path.dirname(f), exist_ok=True)
                        shutil.move(b, f)

    def has_build_file(self, dirname: str) -> bool:
        fname = os.path.join(dirname, environment.build_filename)
        return os.path.exists(fname)

    def validate_core_dirs(self, dir1: T.Optional[str], dir2: T.Optional[str]) -> T.Tuple[str, str]:
        invalid_msg_prefix = f'Neither source directory {dir1!r} nor build directory {dir2!r}'
        if dir1 is None:
            if dir2 is None:
                if not self.has_build_file('.') and self.has_build_file('..'):
                    dir2 = '..'
                else:
                    raise MesonException('Must specify at least one directory name.')
            dir1 = os.getcwd()
        if dir2 is None:
            dir2 = os.getcwd()
        ndir1 = os.path.abspath(os.path.realpath(dir1))
        ndir2 = os.path.abspath(os.path.realpath(dir2))
        if not os.path.exists(ndir1) and not os.path.exists(ndir2):
            raise MesonException(f'{invalid_msg_prefix} exist.')
        try:
            os.makedirs(ndir1, exist_ok=True)
        except FileExistsError as e:
            raise MesonException(f'{dir1} is not a directory') from e
        try:
            os.makedirs(ndir2, exist_ok=True)
        except FileExistsError as e:
            raise MesonException(f'{dir2} is not a directory') from e
        if os.path.samefile(ndir1, ndir2):
            # Fallback to textual compare if undefined entries found
            has_undefined = any((s.st_ino == 0 and s.st_dev == 0) for s in (os.stat(ndir1), os.stat(ndir2)))
            if not has_undefined or ndir1 == ndir2:
                raise MesonException('Source and build directories must not be the same. Create a pristine build directory.')
        if self.has_build_file(ndir1):
            if self.has_build_file(ndir2):
                raise MesonException(f'Both directories contain a build file {environment.build_filename}.')
            return ndir1, ndir2
        if self.has_build_file(ndir2):
            return ndir2, ndir1
        raise MesonException(f'{invalid_msg_prefix} contain a build file {environment.build_filename}.')

    def add_vcs_ignore_files(self, build_dir: str) -> None:
        with open(os.path.join(build_dir, '.gitignore'), 'w', encoding='utf-8') as ofile:
            ofile.write(git_ignore_file)
        with open(os.path.join(build_dir, '.hgignore'), 'w', encoding='utf-8') as ofile:
            ofile.write(hg_ignore_file)

    def validate_dirs(self) -> T.Tuple[str, str]:
        (src_dir, build_dir) = self.validate_core_dirs(self.options.builddir, self.options.sourcedir)
        if Path(build_dir) in Path(src_dir).parents:
            raise MesonException(f'Build directory {build_dir} cannot be a parent of source directory {src_dir}')
        if not os.listdir(build_dir):
            self.add_vcs_ignore_files(build_dir)
            return src_dir, build_dir
        priv_dir = os.path.join(build_dir, 'meson-private')
        has_valid_build = os.path.exists(os.path.join(priv_dir, 'coredata.dat'))
        has_partial_build = os.path.isdir(priv_dir)
        # if has_valid_build:
        #     if not self.options.reconfigure and not self.options.wipe:
        #         print('Directory already configured.\n\n'
        #               'Just run your build command (e.g. ninja) and Meson will regenerate as necessary.\n'
        #               'Run "meson setup --reconfigure to force Meson to regenerate.\n\n'
        #               'If build failures persist, run "meson setup --wipe" to rebuild from scratch\n'
        #               'using the same options as passed when configuring the build.')
        #         if self.options.cmd_line_options:
        #             from . import mconf
        #             raise SystemExit(mconf.run_impl(self.options, build_dir))
        #         raise SystemExit(0)
        # elif not has_partial_build and self.options.wipe:
        #     raise MesonException(f'Directory is not empty and does not contain a previous build:\n{build_dir}')
        return src_dir, build_dir

    # See class Backend's 'generate' for comments on capture args and returned dictionary.
    def generate(self, capture: bool = False, vslite_ctx: T.Optional[dict] = None) -> T.Optional[dict]:
        env = environment.Environment(self.source_dir, self.build_dir, self.options)
        mlog.initialize(env.get_log_dir(), self.options.fatal_warnings)
        if self.options.profile:
            mlog.set_timestamp_start(time.monotonic())
        if self.options.clearcache:
            env.coredata.clear_cache()
        with mesonlib.BuildDirLock(self.build_dir):
            return self._generate(env, capture, vslite_ctx)

    def gen_source(self, env: environment.Environment, target):
        print("==> gen *{}* ====".format(target))
        if "tools_virsh" == target:
            pass
        t_path = os.path.join(env.get_build_dir(), ".deps/d", target)
        d_path = t_path + ".s"
        if not os.path.exists(d_path): return

        s_list = []
        s_buld = []
        s_files = []
        with open(d_path, 'r', encoding='utf-8') as f:
            while True:
                line = f.readline()
                if not line: break

                s_file = os.path.abspath(os.path.join(env.get_build_dir(), line.strip()))
                if not os.path.exists(s_file):
                    print("   ====> miss {}".format(s_file))

                r_file = os.path.relpath(s_file, env.get_build_dir())
                s_files.append(r_file)
                if s_file.startswith(env.get_source_dir()):
                    if r_file not in s_list: s_list.append(r_file)
                elif s_file.startswith(env.get_build_dir()):
                    if r_file not in s_buld: s_buld.append(r_file)
                else : print("  ====> miss {}".format(r_file))

        s_list.sort()
        s_buld.sort()
        filendir = os.path.join(env.get_build_dir(), ".src", target)
        filename = os.path.join(filendir, target + ".s.txt")
        if not os.path.exists(filendir): os.makedirs(filendir)

        with open(filename, 'w', encoding='utf-8') as f:
            f.write('  <ItemGroup>\n')

            for _file in s_buld:
                h_txt = os.path.abspath(_file)[len(env.get_build_dir()) + 1:]
                f.write('    <ClCompile Include="{}" />\n'.format(".builds/" + h_txt))
                if os.path.exists(_file):
                    destfile = os.path.join(filendir, ".builds", h_txt)
                    destdir = os.path.dirname(destfile)
                    if not os.path.exists(destdir): os.makedirs(destdir)
                    shutil.copy(_file, destfile)

            for _file in s_list:
                h_txt = os.path.abspath(_file)[len(env.get_source_dir()) + 1:]
                f.write('    <ClCompile Include="{}" />\n'.format(h_txt))
                if os.path.exists(_file):
                    destfile = os.path.join(filendir, h_txt)
                    destdir = os.path.dirname(destfile)
                    if not os.path.exists(destdir): os.makedirs(destdir)
                    shutil.copy(_file, destfile)

            f.write('  </ItemGroup>')
        
        # 헤더파일
        d_path = t_path + ".d"
        if not os.path.exists(d_path): return

        h_list = []
        h_buld = []
        d_files = []
        o_list = []
        with open(d_path, 'r', encoding='utf-8') as f:
            while True:
                line = f.readline()
                if not line: break
                else: line = line.strip()

                _file = os.path.abspath(os.path.join(env.get_build_dir(), line + ".d"))
                if os.path.exists(_file): d_files.append(_file)
                else:
                    if not line in o_list: o_list.append(line)
                    print("  ====> d file miss {}".format(_file))

        for _file in d_files:
            with open(_file, 'r', encoding='utf-8') as f:
                while True:
                    line = f.readline()
                    if not line: break

                    _files = line.strip().split(' ') # 줄 끝의 줄 바꿈 문자를 제거한다.
                    for r_file in _files:
                        if r_file == '\\': break
                        if r_file in s_files: continue
                        if r_file.endswith('.o:'): continue

                        # if not (h_file.endswith('.h') or h_file.endswith('.c')): continue
                        # r_file = os.path.relpath(s_file, env.get_build_dir())

                        d_file = os.path.abspath(r_file)
                        if d_file.startswith(env.get_source_dir()):
                            if r_file not in h_list: h_list.append(r_file)
                        elif d_file.startswith(env.get_build_dir()):
                            if r_file not in h_buld: h_buld.append(r_file)
                        elif d_file.startswith('/usr/include/'): pass
                        elif d_file.startswith('/usr/lib/'): pass
                        else : print("  ====> h miss {}".format(r_file))

        h_list.sort()
        h_buld.sort()
        filendir = os.path.join(env.get_build_dir(), ".src", target)
        filename = os.path.join(filendir, target + ".h.txt")
        if not os.path.exists(filendir): os.makedirs(filendir)

        with open(filename, 'w', encoding='utf-8') as f:
            f.write('  <ItemGroup>\n')

            for _file in h_buld:
                h_txt = os.path.abspath(_file)[len(env.get_build_dir()) + 1:]
                if h_txt.endswith(".o"): f.write('    <Object Include="{}" />\n'.format(".builds/.ins/" + h_txt))
                else: f.write('    <ClInclude Include="{}" />\n'.format(".builds/.ins/" + h_txt))
                if os.path.exists(_file):
                    destfile = os.path.join(filendir, ".builds/.ins", h_txt)
                    destdir = os.path.dirname(destfile)
                    if not os.path.exists(destdir): os.makedirs(destdir)
                    shutil.copy(_file, destfile)

            for _file in h_list:
                h_txt = os.path.abspath(_file)[len(env.get_source_dir()) + 1:]
                if h_txt.endswith(".o"): f.write('    <Object Include="{}" />\n'.format(h_txt))
                else: f.write('    <ClInclude Include="{}" />\n'.format(h_txt))
                if os.path.exists(_file):
                    destfile = os.path.join(filendir, h_txt)
                    destdir = os.path.dirname(destfile)
                    if not os.path.exists(destdir): os.makedirs(destdir)
                    shutil.copy(_file, destfile)
            f.write('  </ItemGroup>')
        
        t_path = os.path.join(env.get_build_dir(), ".deps/d", target)
        t_path = os.path.join(env.get_build_dir(), ".deps", "targets", target)
        shutil.copy(t_path, os.path.join(filendir, target + ".t.txt"))

    def gen_headers(self, env: environment.Environment):
        print("==== gen_headers ====")
        depdir = os.path.join(env.get_build_dir(), ".deps/d")
        file_list = os.listdir(depdir)
        file_list = [file for file in file_list if file.endswith(".d")]

        for file in file_list:
            file_name, _ = os.path.splitext(file)
            filedir = os.path.join(env.get_build_dir(), ".src", file_name)
            h_list = []
            h_buld = []
            d_files = []
            dfilename = os.path.join(depdir, file)
            with open(dfilename, 'r', encoding='utf-8') as f:
                while True:
                    line = f.readline()
                    if not line: break

                    d_file = os.path.abspath(os.path.join(env.get_build_dir(), line.strip() + ".d"))
                    if os.path.exists(d_file): d_files.append(d_file)

            for d_file in d_files:
                with open(d_file, 'r', encoding='utf-8') as f:
                    while True:
                        line = f.readline()
                        if not line: break

                        h_files = line.strip().split(' ') # 줄 끝의 줄 바꿈 문자를 제거한다.

                        for h_file in h_files:
                            if h_file == '\\': break
                            if not (h_file.endswith('.h') or h_file.endswith('.c')): continue

                            h_abspath = os.path.abspath(os.path.realpath(h_file))

                            if h_abspath.startswith(env.get_source_dir()):
                                h_txt = h_abspath[len(env.get_source_dir()) + 1:]
                                if h_txt not in h_list: h_list.append(h_txt)
                                # print(h_txt)

                            if h_abspath.startswith(env.get_build_dir()):
                                h_txt = h_abspath[len(env.get_build_dir()) + 1:]
                                if h_txt not in h_buld: h_buld.append(h_txt)
                                # print("==>>" + h_txt)

            h_list.sort()
            h_buld.sort()
            directpath = os.path.join(env.get_build_dir(), ".src", file_name)
            filename = os.path.join(directpath, file_name + ".h.txt")
            if not os.path.exists(directpath):
                os.makedirs(directpath)

            with open(filename, 'w', encoding='utf-8') as f:
                f.write('  <ItemGroup>\n')
                for h_file in h_buld:
                    h_txt = os.path.relpath(os.path.join(env.get_build_dir(), h_file))
                    f.write('    <ClInclude Include="{}" />\n'.format(".builds/include/" + h_txt))
                    if os.path.exists(h_txt):
                        destfile = os.path.join(env.get_build_dir(), ".src", file_name, ".builds/include", h_file)
                        destdir = os.path.dirname(destfile)
                        if not os.path.exists(destdir):
                            os.makedirs(destdir)
                        shutil.copy(h_txt, destfile)

                for h_file in h_list:
                    h_txt = os.path.relpath(os.path.join(env.get_source_dir(), h_file))
                    f.write('    <ClInclude Include="{}" />\n'.format(h_file))
                    if os.path.exists(h_txt):
                        destfile = os.path.join(env.get_build_dir(), ".src", file_name, ".include", h_file)
                        destdir = os.path.dirname(destfile)
                        if not os.path.exists(destdir):
                            os.makedirs(destdir)
                        shutil.copy(h_txt, destfile)
                f.write('  </ItemGroup>')

    def _generate(self, env: environment.Environment, capture: bool, vslite_ctx: T.Optional[dict]) -> T.Optional[dict]:
        # Get all user defined options, including options that have been defined
        # during a previous invocation or using meson configure.
        user_defined_options = argparse.Namespace(**vars(self.options))
        coredata.read_cmd_line_file(self.build_dir, user_defined_options)

        mlog.debug('Build started at', datetime.datetime.now().isoformat())
        mlog.debug('Main binary:', sys.executable)
        mlog.debug('Build Options:', coredata.format_cmd_line_options(user_defined_options))
        mlog.debug('Python system:', platform.system())
        mlog.log(mlog.bold('The Meson build system'))
        mlog.log('Version:', coredata.version)
        mlog.log('Source dir:', mlog.bold(self.source_dir))
        mlog.log('Build dir:', mlog.bold(self.build_dir))
        if env.is_cross_build():
            mlog.log('Build type:', mlog.bold('cross build'))
        else:
            mlog.log('Build type:', mlog.bold('native build'))

        cur_dir = os.getcwd()
        os.chdir(env.get_build_dir())

        dep_path = os.path.join(env.get_build_dir(), ".deps", "targets")
        file_list = os.listdir(dep_path)

        # print('\n'.join(file_list))
        for file in file_list:
            self.gen_source(env, file)
        
        # self.gen_headers(env)

        os.chdir(cur_dir)

    def finalize_postconf_hooks(self, b: build.Build, intr: interpreter.Interpreter) -> None:
        b.devenv.append(intr.backend.get_devenv())
        for mod in intr.modules.values():
            mod.postconf_hook(b)

def run_genvslite_setup(options: argparse.Namespace) -> None:
    # With --genvslite, we essentially want to invoke multiple 'setup' iterations. I.e. -
    #    meson setup ... builddirprefix_debug
    #    meson setup ... builddirprefix_debugoptimized
    #    meson setup ... builddirprefix_release
    # along with also setting up a new, thin/lite visual studio solution and projects with the multiple debug/opt/release configurations that
    # invoke the appropriate 'meson compile ...' build commands upon the normal visual studio build/rebuild/clean actions, instead of using
    # the native VS/msbuild system.
    builddir_prefix = options.builddir
    genvsliteval = options.cmd_line_options.pop(mesonlib.OptionKey('genvslite'))
    # The command line may specify a '--backend' option, which doesn't make sense in conjunction with
    # '--genvslite', where we always want to use a ninja back end -
    k_backend = mesonlib.OptionKey('backend')
    if k_backend in options.cmd_line_options.keys():
        if options.cmd_line_options[k_backend] != 'ninja':
            raise MesonException('Explicitly specifying a backend option with \'genvslite\' is not necessary '
                                 '(the ninja backend is always used) but specifying a non-ninja backend '
                                 'conflicts with a \'genvslite\' setup')
    else:
        options.cmd_line_options[k_backend] = 'ninja'
    buildtypes_list = coredata.get_genvs_default_buildtype_list()
    vslite_ctx = {}

    for buildtypestr in buildtypes_list:
        options.builddir = f'{builddir_prefix}_{buildtypestr}' # E.g. builddir_release
        options.cmd_line_options[mesonlib.OptionKey('buildtype')] = buildtypestr
        app = MesonApp(options)
        vslite_ctx[buildtypestr] = app.generate(capture=True)
    #Now for generating the 'lite' solution and project files, which will use these builds we've just set up, above.
    options.builddir = f'{builddir_prefix}_vs'
    options.cmd_line_options[mesonlib.OptionKey('genvslite')] = genvsliteval
    app = MesonApp(options)
    app.generate(capture=False, vslite_ctx=vslite_ctx)

def run(options: T.Union[argparse.Namespace, T.List[str]]) -> int:
    if not isinstance(options, argparse.Namespace):
        parser = argparse.ArgumentParser()
        add_arguments(parser)
        options = parser.parse_args(options)
    coredata.parse_cmd_line_options(options)

    if mesonlib.OptionKey('genvslite') in options.cmd_line_options.keys():
        run_genvslite_setup(options)
    else:
        app = MesonApp(options)
        app.generate()

    return 0
